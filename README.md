
# ❶mac環境構築

<details><summary>クリックで表示</summary>

## homebrew
### *homebrewとは*
- MacやLinuxで使えるパッケージマネジャー（ソフトウェアをインストール・管理するための便利ツール）

⇨Homebrewを使うと、ターミナル上から簡単にツールを入れたりアップデートしたりできる。

 <br/>

### *インストール*
1.  公式サイトからインストール用のコマンドを入手（以下）

```
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

2. terminalに貼り付け実行（パスワードはPCのものを使用）

3. 「Press RETURN to continue or any other key to abort 」が表示されたら、Enterキーで実行

4. 「Installation successful」と出たらインストール完了

5. 以下のコマンドをterminalに入力し、バージョン情報が表示されれば正常
```
brew -v
```

 <br/>

## Git
### *Gitとは*
- コードの変更履歴を記録・管理するためのツール（**ローカル環境**）

    - 特徴：　バージョン管理・履歴・ブランチ機能・共同開発
 <br/>

### *インストール*
Gitは元々インストールされている場合もあるため、まず以下のコマンドで確認する。
```
git -v
```
git versionが表示されればGitは利用可能

*"コマンドラインデベロッパーツールが必要です"と表示された場合はインストールを行う。

完了するとGitが利用できる。

 <br/>

 ## GitHub
 ### *GitHubとは*
- Gitのデータをインターネット上で共有するサービス（**リモート環境**）

    - 特徴：　Gitのリポジトリをクラウド上に・コードの公開・共有

 <br/>

### *Githubアカウント*
Git(hub)の利用にはアカウントの作成が必要
- Github公式サイトにアクセスしてサインアップ⇨
[GitHub](https://github.com/)

<br/>

### *リポジトリの作成*
リポジトリ：　Gitで管理するプロジェクト（コード・ファイル・フォルダ・履歴等）の入れ物

- "New repository"を選択
    - Repository name：プロジェクト名
    - Description(任意)：内容の説明
    - Public / Private：公開設定 *（後で変更可能）*
    - **Initialize this repository with "README file"** ：READMEファイル（説明書）を作る場合チェック☑️



<br/>

## GitHub Desktop
### *GitHub Desktopとは*

- ターミナルを使わなくてもGitを使えるGUIツール

    - 特徴：　管理・コミット（変更記録）・プッシュ・プル・ブランチ切り替え・GitHub接続がカンタンに

<br/>

### *インストール*
1. 公式サイトからアプリをダウンロード⇨[GitHub Desktop](https://github.com/apps/desktop)

2. GitHubアカウントでログイン
3. フォルダやファイルをリポジトリへ登録

<br/>

### *使い方（GitHub Desktop版）*


---
#### push
---
 登録したファイル内容の変更等を保存すると、GitHub Desktop上に反映される

⇨　GitHub Desktop上の"Commit to main"より変更を保存

⇨　"Push origin" でGitHub上にアップロードされる

<br/>

### *使い方（コマンド版）*
ターミナルへのコマンド入力でも同じ操作ができる

git
- clone
- add
- commit
- push
- init
- remote add


<br/>

## Docker
### *Dockerとは*
- アプリと環境設定を丸ごと軽量なパッケージ（＝コンテナ）にすることで、どこでも同じ動作が保証される仕組み
    - イメージ：　コンテナを作るための設計図。OSやソフトウェア、設定が入っている。
    - コンテナ：　実際に動いている実行中の環境＝１つのVM
    - Dokerfile：　イメージを作るためのレシピ。テキストファイルで環境を定義

<br/>

### *インストール*
- Macの場合は**Docker Desktop**を使うとラク

    ⇨DockerはLinuxのVMを使っているため、Desktop版で自動構築してもらうのが簡単

1. 公式サイトからダウンロード⇨[Docker](https://www.docker.com/)

2. アプリケーションフォルダに移動し開く

3. 利用規約に同意、こだわりがなければ推奨設定を利用

4. 動作状況を確認
    - メニューバーに🐳のマークがある場合正常に起動している
    - または、ターミナル上で以下を入力し、バージョン情報が表示されれば正常
    ```
    docker -v
    ```

5. 現在実行中のDockerコンテナを確認

以下のコマンドで起動中のコンテナ一覧が表示される

```
docker ps
```
- `docker ps -a`：すべてのコンテナを表示（停止中含む）
- `docker ps -q`：コンテナIDのみを表示（スクリプトで使うときに便利）

<br/>

## docer-compose
- 複数のDockerコンテナを一括で構成・起動・管理できるツール

- Docker Desktopにcomposeも同梱されており、すぐ使える場合が多い
    - ターミナル上で以下を入力し、バージョン情報が表示されれば正常
    ```
    docker-compose -v
    ```
<br/>

## Visual Studio Code
- 拡張機能が豊富なマルチOSコードエディタ

<br/>

### *インストール*
1. 公式サイトからダウンロード⇨[visuaistudio](https://code.visualstudio.com/)

2. アプリケーションフォルダにインストールして起動
3. 拡張機能でカスタム

    - おすすめカスタム機能⇨[VScodeおすすめカスタム](https://qiita.com/qrrq/items/0e116a59743874d18cb1)

<br/>

### *terminal*
- Macのターミナル（bash,zsh）をVScode内で開いているイメージ

<br/>

## まとめ
以下が確認できればとりあえずOK
- コマンドラインで確認

    - `docker ps`

    - `docker-compose -v`

    - `git -v`

    - `brew -v`

- PCのアプリケーションフォルダで確認

    - github desktop
    - visual studio code

</details>

<br/>

# ❷git初歩とマークダウン

<details><summary>クリックで表示</summary>

## SSH（Secure Shell）
- ネットワークを通じて別のPCと安全に通信するためのプロトコル、SSH鍵ペア（**公開鍵＆秘密鍵**）で認証
- 特徴：暗号化通信、リモートアクセス、トンネリング（他のHTTPなどのプロトコルの通信も安全に）
- **GitHubなど、リモートローカル間でデータをやり取りするにはSSH認証が必要**
- 一般的にHTTPSより安全

**※HTTPS**　ーもう一つの認証方法
- アクセスのたびにユーザー名とパスワード（アクセストークン）を使って認証
- **Web通信**を安全にするために使う

<br/>

### *SSH接続の設定*
#### SSH鍵の作成
1. SShキーを入れるフォルダ（デフォルト）に移動
   ```
   $cd ~/.ssh
    ```
2. コマンドでSSH鍵ペアを生成する
    ```
    ssh-keygen -t rsa
    ```

3. 鍵の保存場所がデフォルトの`~/.ssh/id_rsa `になっていることを確認
4. パスワードの設定（入力が見えないので注意）
5. 任意でパスフレーズを設定（しない場合はエンター）

6. 以下のように生成される

<img src="https://prog-8.com/shared/images/document/34/165533606243.png" width="50%">

引用 > https://prog-8.com/docs/git-env

7. .sshファイル内に鍵が作成できていることを確認
```
ls ~/.ssh
```

#### SSH公開鍵の登録（GitHub）

1. SShキーのフォルダ（デフォルト）に移動
   ```
   $cd ~/.ssh
    ```
2. 公開鍵ファイル内容の閲覧
    ```
    cat id_rsa.pub
    ```
3. `ssh-rsa`から始まり、メールアドレスで終わる長い文字列が公開鍵
4. GitHubにログインし、「Setting > SSH and GPG keys >  New SSH key」へ

   Keyフィールドに先程の公開鍵をコピペ⇨「Add SSH Key」
5. 接続の確認
   ```
   ssh -T git@github.com
   ```
   接続できていれば以下メッセージが表示
   ```
   Hi <Your GitHub Username>! You've successfully authenticated,...
   ```

参考⇩
> https://qiita.com/shizuma/items/2b2f873a0034839e47ce

<br/>

## リポジトリ
リポジトリ：　Gitで管理するプロジェクト（コード・ファイル・フォルダ・履歴等）の入れ物

### *リポジトリの作成*
- "New repository"を選択
    - Repository name：プロジェクト名
    - Description(任意)：内容の説明
    - Public / Private：公開設定 *（後で変更可能）*
    - **Initialize this repository with "README file"** ：READMEファイル（説明書）を作る場合チェック☑️



## clone
- リモート上のリポジトリをローカルに履歴やブランチごとコピーすること
    - 特徴：　ローカルで編集可、バックアップ、バージョン管理

## commit
- ローカルリポジトリ内で変更を保存する操作
    - ファイルの状態、作成者、タイムスタンプなどの情報をもつ
    - コミットメッセージ：変更点を説明するコメントで、履歴を振り返るときに大事

## push
- commitをリモートリポジトリに送信する操作
    - 共有、バックアップになる

<br/>

### *Clone〜Pushまでの流れ　【GitHub Desktop ver.】*
[terminal(コマンド)で行う場合はコチラ](#clonepushまでの流れgitコマンドver)

＜はじめに＞
必要に応じて、ローカル上にGitのリポジトリ（履歴を管理する場所）を作成する。
- プロジェクトのフォルダ内で実行すると、”.git”という隠しフォルダが作成される。（これはバージョン管理に必要な情報を記録する）
- コマンドは以下⇩
    ```
    git init
    ```

＜Clone＞

すでにリモート環境にあるリポジトリを履歴ごとローカルにコピー⇩
```
Git clone <repositoryのURL>
```

＜commit＞

1. commitの準備として、記録したい変更を指定する(ステージング)
```
#変更したファイル名を指定
git add <file>

#現在のフォルダとその中のすべての変更をまとめて指定
git add .
```

2. ステージングした変更をリポジトリに記録（＝Commit）
```
git commit -m "<commit message>"
```

＜push＞

1. ローカルとリモートの接続を設定(リモートリポジトリ名の`<name>`は、通常は`origin`)
```
git remote add <name> <remote_repository_url>
```

2. commitをpush（`<branch＿name>`は送信したいブランチ名、mainやmasterなど）

```
git push <remote_name> <branch_name>

#通常は
git push origin main
```

<br/>

### *Clone〜Pushまでの流れ　【Gitコマンドver.】*

＜Clone＞

1. GitHub Desktopを開き、GitHubアカウントでログイン

2. - 既存リポジトリがない場合

     "Clone a repository from the Internet"を選択
   - 他のリポジトリがある場合

        左上のメニューバーからFile >Clone Repositoryを選択

3. タブからGitHub.com　>　リポジトリ一覧からクローンしたいリポジトリを選択
4. ”Local Path”からローカル上でのコピー先を選択
5. クローンが完了するとGitHub Desktopの画面がクローンしたリポジトリの管理画面に切り替わる

＜commit＞

1. 編集したファイルを保存（必須）

2. GitHub Desktopを開き、保存した変更点が表示されていることを確認

3. 画面左下のCommit Massage（Summary）を記入

4. ”Commit to main”をクリックする

＜push＞

1. GitHub Desktopの画面右上にある"Push origin" をクリック

2. GitHub上で変更点が反映されていれば成功

<br/>

## まとめ
- 安全な通信にはSSH接続が必要
- リモート・ローカル環境間でデータ転送（clone・pushなど）をするにはまずSSH接続
- コマンドを使う時は「現在地cd」と「コマンド」、「接続先」を確認

<br/>

</details>

<br/>

# ❸OS（Linux)ネットワーク

<details><summary>クリックで表示</summary>

## ネットワーク通信の設定
※今回は共有ネットワーク環境へのSSHアクセスを想定

1. SSH接続用の秘密鍵を用意、配置する
- pemファイル（鍵や証明書情報のテキストファイル）をホームディレクトリに配置
   - ない場合は`.ssh`に配置する
   ```
    #.sshの権限を一時変更
    chmod 700 .ssh/

    #pemファイルをダウンロード > .sshへ移動
    mv Downloads/<秘密鍵名.pem> .ssh/

    #pemファイルの権限変更
    chmod 600 .ssh/<秘密鍵名.pem>.pem
    ```

2. リモート環境にログインする

```
# -iで秘密鍵を指定
ssh -i ~/.ssh/<秘密鍵名.pem> <ユーザー名>@<ホスト名またはIPアドレス>
```
**＜2回目以降の接続は上記のコマンドのみ入力すればログイン可能＞**

<br/>

## シェルコマンドの実行
シェルコマンド：コンピュータに指示する言葉

オプション：コマンドの後ろにつけて指示を細かく調整する（-〇〇）

Tab補完：コマンドやファイル名などを、途中で予測して補完してくれる機能

### *基本のシェルコマンド*

#### 場所
- `cd`…ディレクトリに移動
  ```
  #パスを確認
  cd ~/<目的とするディレクトリ名>
  ```
- `find`…特定の条件でファイルやディレクトリを探す
  ```
  #カレントディレクトリ以下から特定の名前のファイルを探す

  find . -name "hoge.txt"
  ```
- `mv`…ファイル移動・ファイル名変更
  ```
  #sampleをDocumentsフォルダへ
  mv sample.txt ~/Documents/

  #oldnameからnewnameへ名称変更
  mv oldname.txt newname.txt
  ```
- `pwd`…カレントディレクトリの絶対パスを表示

#### 表示
- `ls`…ディレクトリ内容の表示
  - `ls -l`：詳細表示(権限や更新日時なども表示)
  - `ls -a`：隠しファイルを含む全てを表示
  - `ls -d`：ディレクトリ自体の内容を表示（中身ではない）
  - `ls -ld`：ディレクトリ自体が存在するかの確認

- `cat`…ファイル内容の全表示（コマンドライン上で）
- `less`…ファイル内容のページごと表示（別ウィンドウで）
    - q：終了　
    - /：検索

#### 作成
- `mkdir`…新しい空ディレクトリの作成
  ```
  mkdir <作成したいディレクトリ名>
  ```

- `touch`…新しい空ファイルの作成(既存のファイル名を指定すると、タイムスタンプのみ更新)
  ```
  touch <作成または更新したいファイル名>
  ```


#### 完全削除（注意！）
- `rm`…ファイル削除
  - `rm -r`…ディレクトリごと削除
  - `rm -i` …削除前に確認（`rm: remove 'file.txt'?`など）

#### その他操作
- `cp`…ファイルをコピー
- `grep`…検索
- `head`/`tail`…先頭/末尾の数行を表示
- `diff`…ファイルの差分を比較
- `wc`…文字数をカウント
- `tar`…アーカイブ（複数ファイルを一つにまとめる）**⇨圧縮はしない**
  ```
  tar [オプション] [アーカイブファイル名] [アーカイブするファイルまたはディレクトリ]
  ```
    - `-c`：新しいアーカイブファイルを作成
    - `-x`：アーカイブファイルを展開

- `zip`…**複数をまとめる＋圧縮**
  ```
  zip（作るZipファイル名）（圧縮するファイル）
  ```
- `unzip`…解凍

#### 特殊記号
- `*`/`?`：ワイルドカード、伏字として使える
- `|`：パイプ、前のコマンドの出力をそのまま次のコマンドに適用
- `>`：リダイレクト、出力を>の右側のファイルに上書き

<br/>

### *＋αコマンド*
<details><summary>クリックで表示</summary>

- `ln`：リンクを作成
  - ハードリンク：元ファイルの中身（inode）を見て、それにつながる別の入口を作成（＝共有）
    ⇨元ファイル消えてもデータ残る
    ```
    ln ファイル名 リンク名
    ```

  - シンボリックリンク：元ファイルへのパスを記録した別ファイルを作成（≒ショートカット）
    ⇨あくまでもショトカなので、元ファイルが消えたら消える
    ```
    ln -s target_directory リンク名
    ```

- `tr`
- `sed`
- `awk`
- `cut`
- `sort`
- `uniq`
- `comm`
- `date`


<br/>

</details>

<br/>

### *vim(vi)*
vim：テキストエディタviの拡張版、高い拡張性と軽い動作
- コマンド上で全て完結
- キーボードで全て操作可能
    - インサートモード：文字の編集
    - コマンドモード：コマンドの実行

#### 使い方
1. ターミナル上で編集したいファイルを指定
   ```
   vim <ファイル名>
   ```

2. vim画面が開く⇨`i`を入力するとインサートモードで編集できる
3. 編集後`esc`でコマンドラインモードへ
4. vimを閉じてターミナルに戻る
   - 保存: `:w`
   - 保存して終了: `:wq` または `:x`
   - 別の名前で保存: `:w <新しいファイル名>`
   - 変更がなければ終了: `:q`
   - 変更があっても強制終了: `:q!`
   - 強制的に保存して終了(権限チェックをすっ飛ばし、擬似sudo状態で書き込める): `:wq!`

## 権限
### *権限 rwxとは*
- ファイルやディレクトリに対するアクセス制御、「誰が」「何の操作を」できるか示す
- r(read・読み取り)、w(write・書き込み)、x(execute・実行)

  - **ファイルの場合**

    r：ファイル内容閲覧（＝`cat`,`less`コマンドが使える）
    w：編集・修正・削除可（＝`echo`,`rm`）
    x：ファイルをプログラムとして実行可
  - **ディレクトリの場合**
    r：ディレクトリ内のファイル名表示（＝`ls`）、**ファイルの中身を見るにはファイルの読み取り権限が別で必要**
    w：ディレクトリ内にファイル作成・名前変更・削除ができる（＝`touch`,`mkdir`,`mv`,`rm`）
    x：**ディレクトリ内に入れる**（＝`cd`）


    ⚠️たとえファイルアクセス権限があっても、そのファイルのあるディレクトリのxがないと操作できない！

<br/>

### *権限の表現方法*
- ユーザー権限は、ファイル所有者（User）・ファイルのグループ（Group）・その他（Others）の順で９ケタで表示される
  ```
  #U=rwx, G=r-x, O=r--の場合

  -rwxr-xr--  1 user group 4096 Apr 20 10:00 my_file.txt
  ```


- 各ユーザーの権限rwxは、０〜７の数字でも表現できる
- r=4, w=2, x=1となっており、権限はこの和で表現される
  - 例：r-x = 4+0+1=5（読み取り＋実行権限あり）
- `chmod`で権限を変更できる
  - ```
    chmod u+x my_script.sh  　# 所有者に実行権限を追加
    ```
  - ```
    chmod 755 my_executable 　# 数値で三者の権限を指定
    ```

参考 > https://qiita.com/shisama/items/5f4c4fa768642aad9e06

<br/>

### *基本の権限コマンド*
   - `chmod`…権限変更
   - `sudo`…＜一時的に＞管理者権限で実行（管理者はroot）

```
# ディレクトリを他人のホームディレクトリに作成

sudo -u <ターゲットユーザー名> mkdir /home/<ターゲットユーザー名>/<作成したいディレクトリ名>
```

   - `sudo -i`…一時的にrootとしログインした状態に
   - `su`…＜完全に＞ユーザー切り替え、パスワード必要、`exit`で元のユーザーへ
   - `chown`…所有者の変更
   - `chgrp`…グループを変更(グループ権限を利用したいときなど)

   - `tmp`…一時ファイルや一時ディレクトリを保存するディレクトリ
     - 通常はホームディレクトリ下に既存
     - 誰でも書き込み可能（＝一時的なファイルの共有場所になる）

<br/>

## ネットワーク通信
### *ローカルとリモート（インスタンス）間のファイル送受信*
#### scp（Secure Copy）
SSHプロトコルを使ったファイルの送受信、安全
- **リモート⇨ローカル**
  ```
  #基本（-iで秘密鍵ファイルを指定）
  scp -i <ローカルの秘密鍵ファイルパス> <リモートのユーザー名>@<リモートホスト>:<リモートのディレクトリパス>
  ```
  - 例(リモートishikawa@18.181.175.189にある、example.txtというファイルを、ローカルDesktopにコピー)
  ```
  scp -i ~/.ssh/training-2025-ishikawa.pem ishikawa@18.181.175.189:~/Kensyu/example.txt ~/Desktop/
  ```

- **ローカル⇨リモート**
  ```
  # ディレクトリの場合`-r`もつける
  scp -r <秘密鍵> <ローカルのディレクトリパス> <リモートのユーザー名>@<リモートホスト>:<リモートのディレクトリパス>

  ```
  - 例
  ```
  scp -r -i ~/.ssh/training-2025-ishikawa.pem ~/Desktop/test ishikawa@18.181.175.189:~/Kensyu/
  ```

#### curl
  様々なプロトコル（HTTPなど）でデータ転送（＝スクリプト向き）
- **Webコンテンツの取得やAPI連携**
  ```
  # ページのHTMLデータを取得
  curl <URL>
  ```

#### wget
 Webからのファイルダウンロードに特化
- Web上のファイルやサイト全体のDLに向く
  ```
  wget <URL>
  ```

<br/>

### *IPアドレス*
ネットワーク上でデバイスを識別し、通信を可能に
- グローバルIPアドレス
  - ネット上の住所、世界で一意
  - ISPが割り当て（動的か固定）
  - ネットと直接通信
- ローカルIPアドレス
  - ローカル上の住所、そのローカル上では一意
  - ルーターが自動割り当て
  - NATによりグローバルIPに変換して通信している

#### IPアドレスの確認
- グローバルIP
  ```
  curl ifconfig.me
  ```

- ローカルIP
  - コマンド
    ```
    # en0は、PC内でWifiを扱っている部分
    ifconfig en0
    ```
  - 設定から

    「システム設定 > ネットワーク > WiFi詳細 > TCP/IP」

<br/>

### *通信系コマンド*
- `ping`…「あるホスト（IPやドメイン）に対して通信が届くか」を調べるコマンド(疎通確認)
  - 他者のPCとの通信
    ```
    ping <通信したいPCのローカルIPアドレス>
    ```

  - 公式サイトとの通信
    ```
    ping <サイトのアドレス>
    ```

<br/>

## まとめ
- ネットワークへのSSH接続をする場合、**秘密鍵**を忘れずに
- コマンドライン上で直接ファイル編集をしたい場合は、適宜vimを使う
- **権限解決**は超大事！ファイル・ディレクトリの権限をそれぞれ確認し、適宜`chmod`
- ローカル・リモート間のデータ送受信は`scp`
- `ping`（疎通確認）はよく使う


</details>

<br/>

# ❹Docker

<details><summary>クリックで表示</summary>

## 仮想化
- 一つの物理的なコンピュータ上で、複数のコンピュータ環境を同時に動作させる技術
- 使いたいハード環境の再現も可（Switchでファミコンのゲームができるみたいな＝ファミコンのような動作環境をソフトウェアで作ってSwitchに入れてる）

  *ホスト型*
  - ハードウェアの上のホストOSにインストールし、その上でゲストOSを管理する
  - OSの上にOSを載せるので負荷大きい

  *ハイパーバイザー型*
  - ハードウェアにインストールし、その上でゲストOSを管理
  - CPU・メモリなどを独立したVMにする、**それぞれがOS（ゲストOS）をもつ**
  - アプリ同士の干渉がない

  *コンテナ型*
  - ホストOSにインストール、その上でアプリケーションを管理
  - アプリ＋実行用の設定等をコンテナという単位で分割、**ホストOSのカーネルを共有**(＝OSレベルでの仮想化)
  - ゲストOSが存在しない⇨起動早い
  - 軽量で高速、移植性が高い、デプロイしやすい


## Docker Engineとは
コンテナ型仮想化ソフトウェア。ホストOSのカーネルを使って動作しており、この上にコンテナを乗せられる。

- **docker CLI**
Docker Engine用のコマンドラインツール

<br/>

## Dockerとは
- コンテナ型仮想化を行うプラットフォームの一つ
  - 環境の再現性高い（パッケージなので）
  - アプリ配布・デプロイが簡単
  - アプリが小さく分割でき、開発が効率化
  - リソース効率が高い（負荷小さい）
  - CI/CDの効率化

### *Dockerの仕組み*
- アプリと環境設定を丸ごと軽量なパッケージ（＝Dockerイメージ）にし、イメージからコンテナという実行環境を起動する
⇨どこでも同じ動作が保証される仕組み

    - Dockerfile：　イメージのレイヤーを作るための設計図。テキストファイルで環境を定義
      - レイヤー式なので、既存のイメージに追加するだけでOK（欲しいコマンドなど書き足す）

    - **イメージ**：　コンテナを作るためのテンプレート。ソフトウェア・設定に関するファイルやメタ情報が入ったレイヤー構造をもつ

    - **コンテナ**：　実際に動作する実行環境＝１つの軽量なVM

- ①既存のイメージを用いてコンテナを作る方法と、②Dockerfile⇨イメージ⇨コンテナの順に作る方法がある


## ①コンテナ起動（既存のイメージを用いる）

### 前提条件
- Docker Desktopがインストール済み
- ターミナルが起動できる

※今回は Ubuntu公式Dockerイメージを使用

### *新しくコンテナを作る*
1. Dockerがインストールされていることを確認
   ```
   docker -v
   ```
2. Docker Hubから、Ubuntu公式イメージをダウンロード
   ```
   docker pull ubuntu
   ```
3. コンテナを起動`docker run`ー　実行するコマンドを指定しないと停止するので、通常はrunのみでは使わない

   ```
   # 対話的なシェルを起動（一般的なコマンド・コンテナ操作が可能）

   docker run -it ubuntu /bin/bash
   ```
4. 起動中のコンテナを確認

   ```
   docker ps
   または
   docker container ls [option]
   ```
- `docker ps -a`：すべてのコンテナを表示（停止中含む）
- `docker ps -q`：コンテナIDのみを表示（スクリプトで使うときに便利）

※今いるコンテナの名前（ID）を知りたい場合`docker ps`は使えないので以下を使う
```
echo $CONTAINER_NAME
```

5. コンテナを停止
   ```
   docker stop <コンテナ名またはID>
   ```
## ②コンテナ起動（Dockerfile⇨イメージ⇨コンテナの順に作る）

1. Dockerfileを読み込んで、指示された手順を実行し、最終的にDockerイメージを生成
   ```
   docker build [オプション] [Docker fileのあるディレクトリパス]
   ```

2. イメージからコンテナを作る（既存の場合と同じ）
   ```
   docker run -it ubuntu /bin/bash
   ```

<br/>

## *既存のコンテナに入る*
1. コンテナを動かす
   ```
   docker start <Dockerの名前かID>
   ```
2. 動かしたコンテナに入る
   （実行中のコンテナ内で新しいコマンドを実行する`exec`）
```
docker exec -it <DockerのID> /bin/bash
```

<br/>

## コンテナ内での操作
- 対話的なシェルを起動していれば、通常のシェルコマンド（`ls` など）でOK
-  vimを開くとき
コンテナ内でのvimインストールが必要（その後は通常と同じ）
```
apt-get update
apt-get install vim
```

※Dockerfileを作る時点でvimの設定を入れておけば、インストールは不要になる

<br/>

### イメージタグとバージョン指定
タグ：イメージのバージョンを識別・特定するラベル

⇨バージョン指定することで、完全に同じ環境を再現できるように

`ubuntu:20.04`＝イメージ名：タグ
※指定しないと`latest`タグになる（非推奨）

<br/>

## バインドマウント
- ホストマシン（Dockerが動作しているPC）のファイル・ディレクトリを、コンテナ内にマウント（接続）する（≒共有フォルダ）
- コンテナ内で変更すると、元ファイルも連動
  - コード変更のたびにコンテナを再構築する必要がなくなる
  - コンテナを削除してもホスト上にデータ残る

<br/>

### *マウントのしかた*
1. マウントしたいホストOSのディレクトリに移動
2. 以下で新たなコンテナを作成
   ※バインドマウントは既存のコンテナにはつけられない

```
<マウントしたいホストOSのディレクトリ> % docker run -it --mount type=bind,source="$(pwd)",target=/app ubuntu /bin/bash
```

またはターミナル上で
```
docker run -it --name <作るコンテナ名> -h dirtest --mount type=bind,src=<ローカルのパス>,dst=/app/dm_test ubuntu /bin/bash
```

<br/>

#### オプション-it
`docker run`に必須のオプション
- コンテナ内でのコマンド入力が可能に・コンテナの出力がターミナルに表示されるようになる

*詳細*

`-i`（ローカルの入力をコンテナの標準入力に接続）と、`-t`（コンテナ内のプロセスがターミナルで動作しているかのように振る舞う）を合体

<br/>

## リモート環境でコンテナを操作
1. リモート環境に接続（SSH）
   ```
   #例
   ssh -i ~/.ssh/training-2025-username.pem <username>@3.112.222.235
   ```
2. 基本コマンドは同様
3. ⚠️**バインドマウントのみ注意**

   直接ローカルからファイルをマウントすることはできない（リモートホストへのファイル転送を挟む必要がある）

   1. ローカルファイルをリモートに転送（scp）
   ```
   # デスクトップのtestディレクトリをリモートのKensyuに転送

   scp -r -i ~/.ssh/training-2025-ishikawa.pem ~/Desktop/test ishikawa@3.112.222.235:~/Kensyu/
   ```
   2. リモートのパス（ローカルファイルを入れたところ）を指定し、バインドマウントした新しいコンテナを作成

    ```
    # リモートホストのKensyuと、コンテナ上の/dm_testをマウント

    docker run -it --name remote_dm -h dirtest --mount type=bind,src=/home/ishikawa/Kensyu/test,dst=/app/dm_test ubuntu /bin/bash
    ```

    3. マウントしたディレクトリに移動し、ローカルのディレクトリ（ファイル）があるか確認
    `cd` `ls -l`

## volume
ボリューム：Docker上にあるデータの永続的な保管場所（≒ハードディスク）


<br/>

## 基本コマンドまとめ
- `docker pull`：イメージを取得
- `docker run`：新しくコンテナを作る
- `docker images``docker image ls`：保存されているイメージを確認
- `docker rm`：コンテナを削除・`rmi`だとイメージを削除
- `docker exec`：実行中のコンテナ内に命令する
- `docker cp`：ホストーコンテナ間でコピー（同期は無し）
- `docker start`：既存のコンテナを起動
- `docker top`：コンテナ内で動作しているプロセスを表示

- `image build`：Dockerfileからイメージを作成

<br/>

## 基本オプションまとめ
- `-it`：`docker run`に必須のオプション
  - コンテナ内でのコマンド入力が可能に・コンテナの出力がターミナルに表示されるようになる
- `-d`：バックグラウンドでコンテナを実行
  - 常に動作させるアプリなど
- `--name`：名前をつける

<br/>

## docker-compose
- 複数のDockerコンテナを一括で構成・起動・管理できるツール
- Yamlファイルにすることで、複数のdockerコマンドをまとめて実行可能

- Docker Desktopにcomposeも同梱されており、すぐ使える場合が多い
    - ターミナル上で以下を入力し、バージョン情報が表示されれば正常
    ```
    docker-compose -v
    ```

<br/>


<br/>

</details>

<br/>

# ❺Git/GitHub

<details><summary>クリックで表示</summary>

## Git
### *Gitとは*
- コードの変更履歴を記録・管理するためのツール（**ローカル環境**）

    - 特徴：　バージョン管理・履歴・ブランチ機能・共同開発

※インストール等については[Mac環境構築](#git)を参照

 <br/>

 ## GitHub
 ### *GitHubとは*
- Gitのデータをインターネット上で共有するサービス（**リモート環境**）
- 特徴：　Gitのリポジトリをクラウド上に・コードの公開・共有

<br/>

## GitHub Desktop
### *GitHub Desktopとは*

- ターミナルを使わなくてもGitを使えるGUIツール

    - 特徴：　管理・コミット（変更記録）・プッシュ・プル・ブランチ切り替え・GitHub接続がカンタンに

<br/>

##　基本用語
- リポジトリ：Gitで管理するプロジェクト（コード・ファイル・フォルダ・履歴等）の入れ物
- working directory（ワークツリー）：ファイルを作成したり編集するディレクトリ
- staging area（インデックス）：次にコミットする変更を一時的に保管

*使い方*

## ①GitHub Desktopの場合
[コマンドの場合はこちら](#コマンドの場合)

### *リポジトリの作成*

- "New repository"を選択
    - Repository name：プロジェクト名
    - Description(任意)：内容の説明
    - Public / Private：公開設定 *（後で変更可能）*
    - **Initialize this repository with "README file"** ：READMEファイル（説明書）を作る場合チェック☑️


<br/>

## ②コマンドの場合（ローカル）

### *リポジトリの作成〜コミットまで*
1. プロジェクト用のルートディレクトリを作成し、移動
   ```
   cd ~/Documents
   mkdir IT-training
   cd IT-training 
   ```
2. `.git`ディレクトリgitのバージョン管理情報全てを格納する隠しディレクトリ）を配置
   - これをルートディレクトリ下におくことでプロジェクトがgitの管理下に入る
  ```
  git init
  ```
3. リポジトリのワーキングディレクトリ下で新規ファイルを作成
   ```
   touch 0423.txt
   ```
4. 新規ファイルをステージングエリアに追加
   ```
   git add 0423.txt
   ```
5. 必要に応じて`git status`で状態を確認
   - ワーキングディレクトリの状態（ステージングまで反映されていない変更やファイルの確認など）
   - ステージングエリアの状態（`git add`されたファイル情報）
6. ステージングエリアの内容をコミット
   ```
   #-m以下はコミットメッセージ
   git commit -m "Add new file: 0423.txt"
   ```
7. `git status`でコミットできているか確認
8. ファイル内容を編集した場合も、同様にadd⇨commit

<br/>

### コミットを修正・取り消す
HEAD：最新のコミット
- `git reset`
  - `--soft`：ステージング・ワーキングの内容は変更せずに、HEADを指定したコミットにする（前のコミットでの変更は、「ステージ前」として残る）
  - 直前のコミットを修正したい場合
  - `--mixed`：ステージングの内容をクリア（前のコミットでの変更は、「ステージ前」として残る）
  - 間違えたコミットを取り消し、ステージングからやり直す場合
  - `--hard`：指定したコミット時の状態に戻す（それ以降のコミット内容は全て破棄）
  - ローカルで履歴を完全削除したい場合（非推奨）

<br/>

- `git log`:リポジトリのコミット履歴を表示する

<br/>

## ブランチ
- プロジェクトの履歴・機能を枝分かれ上に表すもの
  - 並行作業・分離しての機能開発やバグ修正・実験に向いている
- main branch：リポジトリにデフォルトであるブランチ、最終的に全てマージされる幹

### ブランチの作成
1. ブランチの状態の確認（＊ついているのが現在地）
   ```
   #-aでローカル・リモート両方のブランチを表示
   git branch -a
   ```
2. 新しいブランチの作成（新しいブランチは、最初元のブランチと同じ情報をもつ）
   ```
   git branch <ブランチ名>
3. 作成したブランチに切り替える
   ```
   git checkout <切り替えたいブランチ名>
   ```

### ブランチでの操作
1. 操作したいブランチに切り替え`git checkout`
2. ブランチ上でファイルを編集しコミット
3. ブランチ上でpush
4. 元のブランチ（mainなど）にマージする

### GitHubからcloneして編集・Pushする場合
1. GitHubの目的のリポジトリからclone
   ```
   git clone <リポジトリURL>
   ```
2. cloneしてきたリポジトリに移動
3. ブランチの作成・編集・add・commit
4. リモートリポジトリにpush
   ```
   git push -u origin ishikawa
   ```
5. GitHub上に変更が反映されているか確認⇨プルリクエスト
6. マージ

`git stash`：コミットせずに変更内容を保存したいときに、一時的に保存する

※別の場所に移動してコミットする（コミットはしたい）場合はそのまま移動してコミットすればいい



</details>

<br/>